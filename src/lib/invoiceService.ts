import { supabase } from './supabase';

export interface Invoice {
  id: string;
  user_id: string;
  invoice_number: string | null;
  amount: number;
  total_amount: number | null;
  due_date: string;
  status: 'pending' | 'paid' | 'unpaid' | 'overdue' | 'cancelled' | 'partially_paid';
  file_url: string | null;
  payment_link: string | null;
  payment_method: 'stripe' | 'wire' | null;
  paid_at: string | null;
  reminder_sent_at: string | null;
  reminder_count: number;
  line_items: any[];
  shopify_order_ids: string[];
  breakdown: {
    product_cost?: number;
    shipping_cost?: number;
    commission?: number;
    [key: string]: any;
  };
  auto_generated: boolean;
  period_start: string | null;
  period_end: string | null;
  supplier_id: string | null;
  notes: string | null;
  metadata: any;
  created_at: string;
  updated_at: string;
  amount_received: number;
  remaining_amount: number;
  payment_reference: string | null;
  balance_credit_applied: number;
  factory_order_amount?: number;
  user_profile?: {
    email: string;
    first_name: string | null;
    last_name: string | null;
    company: string | null;
  };
}

export interface InvoiceFilters {
  status?: 'all' | 'pending' | 'paid' | 'unpaid' | 'overdue' | 'cancelled' | 'partially_paid';
  userId?: string;
  dateFrom?: string;
  dateTo?: string;
  paymentMethod?: 'stripe' | 'wire';
  autoGenerated?: boolean;
  searchTerm?: string;
}

export interface InvoiceStats {
  total_outstanding: number;
  paid_this_month: number;
  pending_count: number;
  overdue_count: number;
  average_payment_days: number;
  revenue_by_method: {
    stripe: number;
    wire: number;
  };
}

export interface InvoiceAction {
  id: string;
  invoice_id: string;
  action_type: string;
  performed_by_id: string;
  old_value: any;
  new_value: any;
  reason: string | null;
  metadata: any;
  created_at: string;
  performed_by?: {
    email: string;
    first_name: string | null;
    last_name: string | null;
  };
}

export const invoiceService = {
  async getInvoices(filters?: InvoiceFilters, page = 1, pageSize = 50): Promise<{ data: Invoice[]; count: number }> {
    let query = supabase
      .from('invoices')
      .select('*', { count: 'exact' });

    if (filters?.userId) {
      query = query.eq('user_id', filters.userId);
    }

    if (filters?.status && filters.status !== 'all') {
      query = query.eq('status', filters.status);
    }

    if (filters?.dateFrom) {
      query = query.gte('created_at', filters.dateFrom);
    }

    if (filters?.dateTo) {
      query = query.lte('created_at', filters.dateTo);
    }

    if (filters?.paymentMethod) {
      query = query.eq('payment_method', filters.paymentMethod);
    }

    if (filters?.autoGenerated !== undefined) {
      query = query.eq('auto_generated', filters.autoGenerated);
    }

    if (filters?.searchTerm) {
      query = query.ilike('invoice_number', `%${filters.searchTerm}%`);
    }

    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    const { data, error, count } = await query
      .order('created_at', { ascending: false })
      .range(from, to);

    if (error) throw error;

    // Fetch user profiles for all invoices
    const userIds = [...new Set(data?.map(inv => inv.user_id).filter(Boolean))];
    const { data: profiles } = await supabase
      .from('user_profiles')
      .select('user_id, email, first_name, last_name, company')
      .in('user_id', userIds);

    const profileMap = new Map(profiles?.map(p => [p.user_id, p]));

    return {
      data: (data || []).map(inv => {
        const profile = profileMap.get(inv.user_id);
        return {
          ...inv,
          user_profile: profile ? {
            email: profile.email,
            first_name: profile.first_name,
            last_name: profile.last_name,
            company: profile.company
          } : undefined
        };
      }),
      count: count || 0
    };
  },

  async getInvoiceById(invoiceId: string): Promise<Invoice | null> {
    const { data, error } = await supabase
      .from('invoices')
      .select('*')
      .eq('id', invoiceId)
      .maybeSingle();

    if (error) throw error;
    if (!data) return null;

    // Fetch user profile
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('email, first_name, last_name, company')
      .eq('user_id', data.user_id)
      .maybeSingle();

    return {
      ...data,
      user_profile: profile ? {
        email: profile.email,
        first_name: profile.first_name,
        last_name: profile.last_name,
        company: profile.company
      } : undefined
    };
  },

  async getInvoiceStats(userId?: string): Promise<InvoiceStats> {
    const baseQuery = userId
      ? supabase.from('invoices').select('*').eq('user_id', userId)
      : supabase.from('invoices').select('*');

    const { data: allInvoices, error } = await baseQuery;

    if (error) throw error;

    const now = new Date();
    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

    const stats: InvoiceStats = {
      total_outstanding: 0,
      paid_this_month: 0,
      pending_count: 0,
      overdue_count: 0,
      average_payment_days: 0,
      revenue_by_method: {
        stripe: 0,
        wire: 0
      }
    };

    let totalPaymentDays = 0;
    let paidInvoicesCount = 0;

    allInvoices?.forEach(invoice => {
      const amount = invoice.total_amount || invoice.amount;

      if (invoice.status === 'pending' || invoice.status === 'unpaid' || invoice.status === 'overdue') {
        stats.total_outstanding += amount;
      }

      if (invoice.status === 'pending' || invoice.status === 'unpaid') {
        stats.pending_count++;
      }

      if (invoice.status === 'overdue') {
        stats.overdue_count++;
      }

      if (invoice.status === 'paid') {
        const paidDate = new Date(invoice.paid_at || invoice.updated_at);
        if (paidDate >= firstDayOfMonth) {
          stats.paid_this_month += amount;
        }

        if (invoice.payment_method === 'stripe') {
          stats.revenue_by_method.stripe += amount;
        } else if (invoice.payment_method === 'wire') {
          stats.revenue_by_method.wire += amount;
        }

        if (invoice.paid_at) {
          const createdDate = new Date(invoice.created_at);
          const paidDate = new Date(invoice.paid_at);
          const daysDiff = Math.floor((paidDate.getTime() - createdDate.getTime()) / (1000 * 60 * 60 * 24));
          totalPaymentDays += daysDiff;
          paidInvoicesCount++;
        }
      }
    });

    if (paidInvoicesCount > 0) {
      stats.average_payment_days = Math.round(totalPaymentDays / paidInvoicesCount);
    }

    return stats;
  },

  async updateInvoiceStatus(
    invoiceId: string,
    status: Invoice['status'],
    adminId: string,
    reason?: string
  ): Promise<void> {
    const updates: any = { status };

    if (status === 'paid') {
      updates.paid_at = new Date().toISOString();
    }

    const { error } = await supabase
      .from('invoices')
      .update(updates)
      .eq('id', invoiceId);

    if (error) throw error;

    await this.logAction(invoiceId, 'status_changed', adminId, reason);
  },

  async sendPaymentReminder(invoiceId: string): Promise<void> {
    const { data: invoice, error: fetchError } = await supabase
      .from('invoices')
      .select('reminder_count, user_id')
      .eq('id', invoiceId)
      .maybeSingle();

    if (fetchError) throw fetchError;
    if (!invoice) throw new Error('Invoice not found');

    const { error } = await supabase
      .from('invoices')
      .update({
        reminder_sent_at: new Date().toISOString(),
        reminder_count: (invoice.reminder_count || 0) + 1
      })
      .eq('id', invoiceId);

    if (error) throw error;

    // TODO: Send email notification via edge function
  },

  async generatePaymentLink(
    invoiceId: string,
    method: 'stripe' | 'wise'
  ): Promise<string> {
    // TODO: Implement Stripe/Wise payment link generation via edge function
    // For now, return a placeholder
    const paymentLink = `https://pay.revoa.app/invoice/${invoiceId}`;

    const { error } = await supabase
      .from('invoices')
      .update({ payment_link: paymentLink })
      .eq('id', invoiceId);

    if (error) throw error;

    return paymentLink;
  },

  async markAsPaid(
    invoiceId: string,
    paymentMethod: 'stripe' | 'wire',
    referenceNumber: string,
    adminId: string
  ): Promise<void> {
    const { error } = await supabase
      .from('invoices')
      .update({
        status: 'paid',
        paid_at: new Date().toISOString(),
        payment_method: paymentMethod,
        payment_reference: referenceNumber || null,
        notes: referenceNumber ? `Payment reference: ${referenceNumber}` : null
      })
      .eq('id', invoiceId);

    if (error) throw error;

    await this.logAction(
      invoiceId,
      'marked_paid',
      adminId,
      `Payment method: ${paymentMethod}, Reference: ${referenceNumber}`
    );
  },

  async applyPaymentWithReconciliation(
    invoiceId: string,
    amountReceived: number,
    paymentMethod: 'stripe' | 'wire',
    referenceNumber: string,
    adminId: string
  ): Promise<{
    success: boolean;
    overpayment?: number;
    underpayment?: number;
    newBalanceCredit?: number;
  }> {
    const invoice = await this.getInvoiceById(invoiceId);
    if (!invoice) throw new Error('Invoice not found');

    const totalAmount = invoice.total_amount || invoice.amount;
    const difference = amountReceived - totalAmount;

    if (difference >= 0) {
      const { error: updateError } = await supabase
        .from('invoices')
        .update({
          status: 'paid',
          paid_at: new Date().toISOString(),
          payment_method: paymentMethod,
          payment_reference: referenceNumber || null,
          amount_received: amountReceived,
          remaining_amount: 0,
          notes: referenceNumber ? `Payment reference: ${referenceNumber}` : null
        })
        .eq('id', invoiceId);

      if (updateError) throw updateError;

      if (difference > 0) {
        const { data: balanceAccount, error: balanceError } = await supabase
          .from('balance_accounts')
          .select('id, current_balance')
          .eq('user_id', invoice.user_id)
          .maybeSingle();

        if (balanceError) throw balanceError;

        const currentBalance = balanceAccount?.current_balance || 0;
        const newBalance = currentBalance + difference;

        if (balanceAccount) {
          await supabase
            .from('balance_accounts')
            .update({
              current_balance: newBalance,
              last_transaction_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('id', balanceAccount.id);
        } else {
          await supabase
            .from('balance_accounts')
            .insert({
              user_id: invoice.user_id,
              current_balance: difference,
              currency: 'USD'
            });
        }

        await supabase
          .from('balance_transactions')
          .insert({
            user_id: invoice.user_id,
            type: 'payment',
            amount: difference,
            balance_after: newBalance,
            description: `Overpayment credit from invoice ${invoice.invoice_number || invoiceId.slice(0, 8)}`,
            reference_type: 'invoice',
            reference_id: invoiceId,
            metadata: {
              payment_method: paymentMethod,
              payment_reference: referenceNumber,
              original_invoice_amount: totalAmount,
              amount_received: amountReceived
            }
          });
      }

      await this.logAction(
        invoiceId,
        'payment_received',
        adminId,
        `Full payment received: $${amountReceived.toFixed(2)}. ${difference > 0 ? `Overpayment of $${difference.toFixed(2)} credited to balance.` : ''}`
      );

      return {
        success: true,
        overpayment: difference > 0 ? difference : undefined,
        newBalanceCredit: difference > 0 ? difference : undefined
      };
    } else {
      const remainingAmount = Math.abs(difference);

      const { error: updateError } = await supabase
        .from('invoices')
        .update({
          status: 'partially_paid',
          payment_method: paymentMethod,
          payment_reference: referenceNumber || null,
          amount_received: amountReceived,
          remaining_amount: remainingAmount,
          notes: `Partial payment received: $${amountReceived.toFixed(2)}. Remaining: $${remainingAmount.toFixed(2)}`
        })
        .eq('id', invoiceId);

      if (updateError) throw updateError;

      await this.logAction(
        invoiceId,
        'partial_payment_received',
        adminId,
        `Partial payment of $${amountReceived.toFixed(2)} received. Remaining balance: $${remainingAmount.toFixed(2)}`
      );

      return {
        success: true,
        underpayment: remainingAmount
      };
    }
  },

  async getUnpaidInvoices(userId?: string, adminFilter?: string): Promise<Invoice[]> {
    let merchantIds: string[] | null = null;

    if (userId) {
      merchantIds = [userId];
    } else if (adminFilter && adminFilter !== 'all') {
      const { data: assignments } = await supabase
        .from('user_assignments')
        .select('user_id')
        .eq('admin_id', adminFilter);

      if (assignments && assignments.length > 0) {
        merchantIds = assignments.map(a => a.user_id);
      } else {
        return [];
      }
    }

    let query = supabase
      .from('invoices')
      .select('*')
      .in('status', ['unpaid', 'pending', 'overdue', 'partially_paid'])
      .order('due_date', { ascending: true });

    if (merchantIds) {
      query = query.in('user_id', merchantIds);
    }

    const { data, error } = await query;

    if (error) throw error;

    if (!data || data.length === 0) return [];

    const userIds = [...new Set(data.map(inv => inv.user_id).filter(Boolean))];
    const { data: profiles } = await supabase
      .from('user_profiles')
      .select('id, email, first_name, last_name, company')
      .in('id', userIds);

    const profileMap = new Map(profiles?.map(p => [p.id, p]));

    return data.map(inv => {
      const profile = profileMap.get(inv.user_id);
      return {
        ...inv,
        user_profile: profile ? {
          email: profile.email,
          first_name: profile.first_name,
          last_name: profile.last_name,
          company: profile.company
        } : undefined
      };
    });
  },

  async getPaidInvoicesForFactory(userId?: string, adminFilter?: string): Promise<Invoice[]> {
    let merchantIds: string[] | null = null;

    if (userId) {
      merchantIds = [userId];
    } else if (adminFilter && adminFilter !== 'all') {
      const { data: assignments } = await supabase
        .from('user_assignments')
        .select('user_id')
        .eq('admin_id', adminFilter);

      if (assignments && assignments.length > 0) {
        merchantIds = assignments.map(a => a.user_id);
      } else {
        return [];
      }
    }

    let query = supabase
      .from('invoices')
      .select('*')
      .eq('status', 'paid')
      .or('factory_order_placed.is.null,factory_order_placed.eq.false')
      .order('paid_at', { ascending: true });

    if (merchantIds) {
      query = query.in('user_id', merchantIds);
    }

    const { data, error } = await query;

    if (error) throw error;

    if (!data || data.length === 0) return [];

    const userIds = [...new Set(data.map(inv => inv.user_id).filter(Boolean))];
    const { data: profiles } = await supabase
      .from('user_profiles')
      .select('id, email, first_name, last_name, company')
      .in('id', userIds);

    const profileMap = new Map(profiles?.map(p => [p.id, p]));

    const { data: allocations } = await supabase
      .from('invoice_factory_allocations')
      .select('invoice_id, amount_allocated')
      .in('invoice_id', data.map(inv => inv.id));

    const allocationMap = new Map<string, number>();
    allocations?.forEach(alloc => {
      const current = allocationMap.get(alloc.invoice_id) || 0;
      allocationMap.set(alloc.invoice_id, current + alloc.amount_allocated);
    });

    return data.map(inv => {
      const profile = profileMap.get(inv.user_id);
      const factoryOrderAmount = allocationMap.get(inv.id) || 0;
      const totalAmount = inv.total_amount || inv.amount;

      return {
        ...inv,
        factory_order_amount: factoryOrderAmount,
        user_profile: profile ? {
          email: profile.email,
          first_name: profile.first_name,
          last_name: profile.last_name,
          company: profile.company
        } : undefined
      };
    }).filter(inv => {
      const totalAmount = inv.total_amount || inv.amount;
      const orderedAmount = inv.factory_order_amount || 0;
      return orderedAmount < totalAmount;
    });
  },

  async getInvoiceActions(invoiceId: string): Promise<InvoiceAction[]> {
    const { data, error } = await supabase
      .from('invoice_actions')
      .select(`
        *,
        user_profiles!invoice_actions_performed_by_id_fkey (
          email,
          first_name,
          last_name
        )
      `)
      .eq('invoice_id', invoiceId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return (data || []).map(action => ({
      ...action,
      performed_by: action.user_profiles
    }));
  },

  async logAction(
    invoiceId: string,
    actionType: string,
    performedById: string,
    reason?: string,
    oldValue?: any,
    newValue?: any
  ): Promise<void> {
    const { error } = await supabase
      .from('invoice_actions')
      .insert({
        invoice_id: invoiceId,
        action_type: actionType,
        performed_by_id: performedById,
        reason,
        old_value: oldValue,
        new_value: newValue
      });

    if (error) throw error;
  },

  async bulkUpdateStatus(
    invoiceIds: string[],
    status: Invoice['status'],
    adminId: string
  ): Promise<void> {
    const updates: any = { status };

    if (status === 'paid') {
      updates.paid_at = new Date().toISOString();
    }

    const { error } = await supabase
      .from('invoices')
      .update(updates)
      .in('id', invoiceIds);

    if (error) throw error;

    // Log actions for each invoice
    await Promise.all(
      invoiceIds.map(id => this.logAction(id, 'status_changed', adminId, 'Bulk update'))
    );
  },

  async bulkSendReminders(invoiceIds: string[]): Promise<void> {
    for (const invoiceId of invoiceIds) {
      await this.sendPaymentReminder(invoiceId);
    }
  },

  async getOverdueInvoices(userId?: string): Promise<Invoice[]> {
    let query = supabase
      .from('invoices')
      .select('*')
      .eq('status', 'overdue');

    if (userId) {
      query = query.eq('user_id', userId);
    }

    const { data, error } = await query.order('due_date', { ascending: true });

    if (error) throw error;

    // Fetch user profiles
    const userIds = [...new Set(data?.map(inv => inv.user_id).filter(Boolean))];
    const { data: profiles } = await supabase
      .from('user_profiles')
      .select('user_id, email, first_name, last_name, company')
      .in('user_id', userIds);

    const profileMap = new Map(profiles?.map(p => [p.user_id, p]));

    return (data || []).map(inv => {
      const profile = profileMap.get(inv.user_id);
      return {
        ...inv,
        user_profile: profile ? {
          email: profile.email,
          first_name: profile.first_name,
          last_name: profile.last_name,
          company: profile.company
        } : undefined
      };
    });
  },

  async updateOverdueInvoices(): Promise<void> {
    const { error } = await supabase.rpc('update_overdue_invoices');
    if (error) throw error;
  },

  subscribeToInvoiceChanges(userId: string, callback: (payload: any) => void) {
    return supabase
      .channel(`invoices:${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'invoices',
          filter: `user_id=eq.${userId}`
        },
        callback
      )
      .subscribe();
  }
};
